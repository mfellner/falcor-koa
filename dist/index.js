'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dataSourceRoute = dataSourceRoute;

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const parseArgs = Object.freeze({
  jsonGraph: true,
  callPath: true,
  arguments: true,
  pathSuffixes: true,
  paths: true
}); /**!
     * falcor-koa - index.js
     * Copyright(c) 2015
     * Released under the Apache-2.0 license
     *
     * Authors:
     * mfellner <max.fellner@gmail.com>
     */

function requestToContext(req) {
  const queryMap = req.method === 'POST' ? req.body : _url2.default.parse(req.url, true).query;
  const context = {};

  if (queryMap) {
    Object.keys(queryMap).forEach(key => {
      let arg = queryMap[key];

      if (parseArgs[key] && arg) {
        context[key] = JSON.parse(arg);
      } else {
        context[key] = arg;
      }
    });
  }
  return Object.freeze(context);
}

function dataSourceRoute(dataSource) {
  return function* (next) {
    if (!dataSource) {
      this.throw('Undefined data source', 500);
    }

    const ctx = requestToContext(this.request);

    if (Object.keys(ctx).length === 0) {
      this.throw('Request not supported', 500);
    }
    if (!ctx.method || !ctx.method.length) {
      this.throw('No query method provided', 500);
    }
    if (!dataSource[ctx.method]) {
      this.throw(`Data source does not implement method ${ ctx.method }`, 500);
    }

    const observable = ({
      'set': () => dataSource[ctx.method](ctx.jsonGraph),
      'call': () => dataSource[ctx.method](ctx.callPath, ctx.arguments, ctx.pathSuffixes, ctx.paths),
      'get': () => dataSource[ctx.method]([].concat(ctx.paths || [])),
      'undefined': () => this.throw(`Unsupported method ${ ctx.method }`, 500)
    })[ctx.method]();

    // Note: toPromise could be removed in the future (https://github.com/Netflix/falcor/issues/464)
    this.body = yield observable.toPromise();
  };
}